#!/opt/x11r6/tk-tcl/bin/expect -f
#
# This Expect script was generated by autoexpect on Thu Oct 25 07:36:04 2012
# Expect and autoexpect were both written by Don Libes, NIST.
#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don

set cnfgIP 135.252.226.34
set cmdstr "ims_cli -a get -t reg -p cnt -v 2 -n ims"
set cmdresult "cmd_result"
set saveresultcmd "tail -c 0 -f logs/protocolmonitor.log >$cmdresult &"

log_file -noappend expect.out

# set input param
foreach {opt val} $argv {
        switch $opt {
        "cnfgIP"      {
            set cnfgIP $val
            #send_user "set CNFG IP: $val"
        }
        "cmdstr"      {
            set cmdstr $val
            #send_user "set command: $val"
        }
        default         {
            #send_user "unknown param\n"
            }
        }
}

set timeout 10
match_max 100000

spawn telnet $cnfgIP
expect {
        -gl     "login:"  {
                exp_send "lss\n"
                exp_continue
        }
        -gl     "Password:"     {
                exp_send "lss\n"
                exp_continue
        }
        -gl     "Enter return to acknowledge message of the day:"     {
                exp_send "\n"
                exp_continue
        }

        -gl     "Command line editor? (default = vi):"     {
                exp_send "\n"
                exp_continue
        }

        -gl     "/export/home/lss:"   {
                #send_user "Log in $cnfgIP\n"
                set msg "login successful"
        }
        timeout {
            #send_user "failed to log in $cnfgIP\n"
            exit 1
        }
}

send -- "$saveresultcmd\n"
set tailPID 99999
expect -re "\[\r\n\]+.*\[\[0-9\]+\]     (\[0-9\]+)\[\r\n\]+" {
        set tailPID $expect_out(1,string) 
}

send -- "$cmdstr\n"
#puts "run $cmdstr\n"
sleep 2 
#puts "kill tail process $tailPID\n"
send -- "kill -9 $tailPID\n"
send -- "exit\n"

expect -gl "Connection closed by foreign host." {
	#send_user "closed the connection to lab $cnfgIP\n"
}

spawn scp lss@$cnfgIP:/export/home/lss/$cmdresult .
expect  {

        -gl     "continue connecting (yes/no)"  {
                exp_send "yes\n"
                exp_continue
        }
        -gl     "Password"      {
                exp_send "lss\n"
                exp_continue
        }
        -gl     "Host key verification failed"     {
                exp_send ">/root/.ssh/known_hosts\n"
                exp_continue
        }
        timeout {
            #send_user "scp timeout\n"
            exit 1
        }
}
log_file
#expect eof
